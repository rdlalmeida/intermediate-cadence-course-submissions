Q1. Describe the access(contract) pattern in words.

<code>access(contract)</code> is an access modifier that restricts the access to a resource, variable or function to within the contract where that element is specified, as well as limits the user access to the contract deployer only, if these elements are defined with this access modifier in a public interface.
In the ExampleNFT used, the <code>access(contract)</code> modifier was used to define functions that can only be called by a specific resource, through a function wrapper (the <code>lockUserCollection(collection: &Collection{CollectionPublic})</code> function). As long as the creation of this resource is kept within the bounds of the contract, i.e., without allowing other users to create Admin resources by exposing a <code>pub fun createAdmin()</code> function for example, and this resource is created a stored in the contract's init function, that restricts the execution of <code>access(contract)</code> function, as well as resources and variables with the same access modifier and are available inside the Admin resource, to the contract deployer, since he's the only one that can borrow or load it from storage.

Q2. Come up with your own unique example of when the access(contract) pattern could be used.

<code>access(contract)</code> modifiers alongside with an Admin-like resource that's only accessible to the contract deployer are very handy to establish control in a decentralized environment in my opinion, a nice way to employ a bit of centralized control in order to enforce honesty.
For example, lets imagine a project on Flow based on the exchange of NFTs between users, with the whole thing being implemented with a single contract, or at least a main one that defines the main aggregator (Collection, Vault, etc.) of these NFTs, like an NFT-based Magic the Gathering game of sorts (pretty sure that are a few like that already). Let's also imagine that this contract allows for card (the NFT equivalent) exchanges between users in a non-standard way, i.e., there's no table or reference that says that a Shivan Dragon is worth 3 Lightning Bolts and a Howling Mine (I'm using examples from when I used to play this game back in the day...) but two player can talk in a chat and arrange that swap between them. Because of the complexity of the trade, its not feasible to create a transaction template to do this in a "secure" way that ensures that each player has the initial cards to begin with and ends up with them after the trade (or maybe there is, but for the sake of this example, lets assume that the contract developer is lazy and there's not). So the trade rests mainly on the honesty of the two parts. But what if one of the players is not honest? What if he convinces the first one to transfer the valuable Shivan Dragon and refuses to either transfer the accorded set back to him or transfers a cheap pair of Llanowar Elves instead?
One way to protect this game against cheaters like that is to keep a sort of "adminWithdraw" function in the contract, as well as a pair of functions to get the cards in a user's collection, protected with <code>access(contract)</code> whose execution is limited to an Admin Resource, similar to what happened in the example used.
The only thing that needs had to be recorded in the blockchain was the trade details, and that could be easily be done with a script or events, basically stating that user A is sending X to user B and the latter sends Y to the former, with the trade itself being solely from the responsibility of the users. If one of the users got short changed, he could appeal to the Administrator (contract deployer) and, if he was able to convince him that he was cheated, the Admin could simply force the Shivan Dragon away from the cheater's collection with the adminWithdraw, or even penalizing him further by forcing some other cards from his collection to the cheated's collection.

Q3. Based on the following diagram, do you think this pattern could also be used with access(account)?

Yes. <code>access(account)</code> is slightly less restrictive than <code>access(contract)</code> so we can enact that same behavior with this access modifier. If a admin user wanted to establish this type of control in a series of contracts instead of a single one, with them all deployed into his own account, a more practical approach would be to define a single Admin resource, in a contract that imported all the other contracts, and implement function wrappers in that Admin Resource to control locks in several contracts from the same resource, a sort of Super Master Admin that could control a bunch of projects from the same resource.

Q4. Using the FLOAT Contract, find at least one example of the access(contract) pattern being used (hint: if your answer to quest #3 is correct, you should be able to find one by searching all the public interfaces for a certain function that has a specific access modifier).

I couldn't find a single instance of <code>access(contract)</code>, which shouldn't be a surprise considering considering the inconspicuous hint there eh eh, but there are plenty of examples of <code>access(account)</code>, which I assumed to enact the same behavior. A good example of a function that should be protected from public access is perhaps:
```cadence
access(account) fun removeEvent(eventId: UInt64) {
    self.events.remove(key: eventId)
}
```
Events are, understandably so, protected from pub access, and a function to remove them should be that protected as well.