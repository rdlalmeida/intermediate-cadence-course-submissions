1. Explain the self.owner!.address pattern.

The <code>self</code> part relates to the resource in question, where the function may be written into. <code>owner</code> is an implicit field that, according to the documentation, is of the PublicAccount? type. <code>address</code> is a subfield of the <code>owner</code> and it is of the <code>Address</code> type. Since the owner is a PublicAccount?, i.e., it can be a nil, the '!' operator must be used when accessing this one.
When a resource is saved into storage, this field is associated to a reference retrieved from it. The <code>owner</code> part refers to the Account where the resource is stored.

2. You may be wondering: "Why do we have to add a force-unwrap operator (!) after self.owner?" Good question! Can you make a guess as to when self.owner would be nil?

If the resource in question is not saved into a storage path, this field is nil. Actually, this field is actually in references obtained to that resource, but never in the resource itself. For example, if I create a transaction that creates an Identity from the Profile contract and try to create a new Profile without saving it first and invoking the createProfile function from the reference instead, i.e., invoking the createProfile function directly from resource itself, the transactions is going to fail in the precondition, not because of the condition itself, but because it tries to index the Profile dictionary with a <code>self.owner!.address</code> while <code>self.owner</code> is still nill. Only a reference to an Identity resource that was previously saved to storage has this field properly set. 

3. Come up with your own example where you utilize self.owner!.address, and explain why you had to use it there.

In general terms, this feature is really useful to ensure that a proper resource exists in storage before potentially dangerous action can be taken. A good example where this can be useful is in a function that moves an NFT from one account to the other, such as in the case of a sell. Accessing and printing <code>self.owner!.address</code> ensures that the NFT was indeed stored into the storage of the account indicated, since any other case will either show a different address (an very difficult scenario since the owner of that account would have to sign that transaction as well) or stops the transaction due to <code>self.owner</code> being nil, if the NFT was not saved into an account at the point where the access is made. This ensures that a resource was properly moved to the intended account storage without requiring much work.

4. Take a look at the FLOAT contract on Mainnet here. Find an example of self.owner!.address and explain what it is doing there (hint: look at the createEvent function).

The best example in that contract is indeed in the <code>createEvent</code> function. This function creates a new Event but this has to necessarily be under a FLOATEvents Collection. This collection needs to be created, stored and its functions, such as the createEvent one, accessed via a reference borrowed from the stored reference. If that is not the case, creating a new Event will fail when it tries to set the host field in the new Event, since the <code>self.owner</code> field is nil otherwise. In this case, the <code>self.owner!.address</code> is going to indicate the address of the account where the FLOATEvents collection is currently stored.
Additionally, a similar strategy is used in the normal FLOAT collection, where the Deposit and Withdraw Events are created using the <code>self.owner!.address</code> as argument, which required that the Collection to be stored in a user's account the functions that create such events are being accessed through a reference to the Collection resource instead of the resource itself, as intended.